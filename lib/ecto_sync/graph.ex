defmodule EctoSync.Graph do
  @moduledoc false
  alias Ecto.ERD.{Edge, Node, Field}
  import EctoSync.Helpers, only: [ecto_schema_mod?: 1]
  defstruct [:edges, :nodes]
  require Logger
  @type t :: %__MODULE__{}

  def new(modules, relation_types) do
    data =
      modules
      |> Enum.flat_map(fn module -> components(module, relation_types) end)
      |> Enum.group_by(fn
        %Edge{} -> :edges
        %Node{} -> :nodes
      end)

    %__MODULE__{
      # multiple nodes could be generated by multiple schemas which use the same table in many to many relation
      edges: Enum.uniq(Map.get(data, :edges, []))
    }
  end

  defp components(schema_module, relation_types) do
    if ecto_schema_mod?(schema_module) do
      relation_components =
        Enum.flat_map(relation_types, &components_from_relations(schema_module, &1))

      primary_keys = schema_module.__schema__(:primary_key)

      node =
        Node.new(
          schema_module,
          schema_module.__schema__(:source),
          Enum.map(
            schema_module.__schema__(:fields),
            fn field ->
              Field.new(%{
                name: field,
                type: schema_module.__schema__(:type, field),
                primary?: field in primary_keys
              })
            end
          )
        )

      [node | relation_components]
    else
      Logger.warning("Skipping schema #{schema_module}: not found")
      []
    end
  end

  defp components_from_relations(module, :associations) do
    :associations
    |> module.__schema__()
    |> Enum.flat_map(fn assoc_field ->
      from_relation_struct(module.__schema__(:association, assoc_field))
    end)
  end

  defp components_from_relations(module, :embeds) do
    :embeds
    |> module.__schema__()
    |> Enum.flat_map(fn embed_field ->
      from_relation_struct(module.__schema__(:embed, embed_field))
    end)
  end

  defp from_relation_struct(%Ecto.Embedded{
         owner: owner,
         related: related,
         field: field,
         cardinality: cardinality
       }) do
    if ecto_schema_mod?(related) do
      [
        Edge.new(%{
          from: {owner.__schema__(:source), owner, {:field, field}},
          to: {related.__schema__(:source), related, {:header, :schema_module}},
          assoc_types: [has: cardinality]
        })
      ]
    else
      Logger.warning(
        "Skipping association `embeds_#{cardinality} #{inspect(field)}` in schema #{inspect(owner)}: #{inspect(related)} is not an Ecto schema"
      )

      []
    end
  end

  defp from_relation_struct(%Ecto.Association.BelongsTo{
         owner: owner,
         owner_key: owner_key,
         related: related,
         related_key: related_key,
         field: field
       }) do
    if ecto_schema_mod?(related) do
      related_source = related.__schema__(:source)
      owner_source = owner.__schema__(:source)

      [
        Edge.new(%{
          from: {related_source, owner, {:field, related_key}},
          to: {owner_source, related, {:field, owner_key}},
          assoc_types: [:belongs_to],
          via: {field, nil}
        })
      ]
    else
      Logger.warning(
        "Skipping association `belongs_to #{inspect(field)}` in schema #{inspect(owner)}: #{inspect(related)} is not an Ecto schema"
      )

      []
    end
  end

  defp from_relation_struct(%Ecto.Association.Has{
         owner: owner,
         owner_key: owner_key,
         related: related,
         related_key: related_key,
         cardinality: cardinality,
         field: field
       }) do
    if ecto_schema_mod?(related) do
      related_source = related.__schema__(:source)
      owner_source = owner.__schema__(:source)

      [
        Edge.new(%{
          from: {owner_source, owner, {:field, owner_key}},
          to: {related_source, related, {:field, related_key}},
          assoc_types: [has: cardinality],
          via: {field, nil}
        })
      ]
    else
      Logger.warning(
        "Skipping association `has_#{cardinality} #{inspect(field)}` in schema #{inspect(owner)}: #{inspect(related)} is not an Ecto schema"
      )

      []
    end
  end

  defp from_relation_struct(%Ecto.Association.ManyToMany{
         join_through: join_through,
         owner: owner,
         field: field,
         related: related,
         join_keys: [{join_source_owner_fk, owner_pk}, _]
       }) do
    if ecto_schema_mod?(related) do
      {join_module, join_source} =
        case join_through do
          value when is_atom(value) ->
            {join_through, value.__schema__(:source)}

          value when is_binary(value) ->
            {nil, value}
        end

      [
        Edge.new(%{
          from: {owner.__schema__(:source), owner, {:field, owner_pk}},
          to: {join_source, related, {:field, join_source_owner_fk}},
          assoc_types: [has: :many],
          via: {field, join_through}
        })
      ]
    end
  end

  defp from_relation_struct(%Ecto.Association.HasThrough{}) do
    []
  end
end
